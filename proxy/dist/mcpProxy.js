import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "node:url";
import { dirname } from "node:path";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
export async function loadMcpConfig() {
    try {
        // Load base config
        const baseConfigPath = path.resolve(__dirname, "../../config/mcp.config.json");
        console.log("\n=== Config Loading Debug ===");
        console.log("Loading base config from:", baseConfigPath);
        const baseConfig = JSON.parse(await fs.readFile(baseConfigPath, "utf-8"));
        console.log("Base config loaded successfully");
        console.log("Base servers:", Object.keys(baseConfig.mcpServers));
        // Try to load custom config if it exists
        let customConfig = { mcpServers: {} };
        try {
            const customConfigPath = path.resolve(__dirname, "../../config/mcp.config.custom.json");
            console.log("\nTrying to load custom config from:", customConfigPath);
            const customConfigContent = await fs.readFile(customConfigPath, "utf-8");
            console.log("Custom config content:", customConfigContent);
            customConfig = JSON.parse(customConfigContent);
            console.log("Custom config loaded successfully");
            console.log("Custom servers:", Object.keys(customConfig.mcpServers));
        }
        catch (error) {
            console.log("\nNo custom config found:", error instanceof Error ? error.message : String(error));
        }
        // Ensure core servers have proper args before merging
        Object.entries(baseConfig.mcpServers).forEach(([id, serverConfig]) => {
            if (serverConfig &&
                typeof serverConfig === "object" &&
                "metadata" in serverConfig &&
                serverConfig.metadata?.serverType === "core") {
                serverConfig.args = ["-y", id];
            }
        });
        // Merge configs, with custom taking precedence
        const mergedConfig = {
            ...baseConfig,
            mcpServers: {
                ...baseConfig.mcpServers,
                ...Object.entries(customConfig.mcpServers).reduce((acc, [key, config]) => ({
                    ...acc,
                    [key]: {
                        ...config,
                        metadata: {
                            ...(config.metadata || {}),
                            serverType: "custom", // Mark as custom server
                        },
                    },
                }), {}),
            },
            customServers: customConfig.mcpServers,
        };
        // Add warning header
        const configWithHeader = {
            _warning: "This file is automatically generated. DO NOT EDIT DIRECTLY.",
            ...mergedConfig,
        };
        // Write back the updated config with defaults
        const configPath = path.resolve(__dirname, "../../config/mcp.config.json");
        await fs.writeFile(configPath, JSON.stringify(configWithHeader, null, 2));
        console.log("\n=== Config Merging Results ===");
        console.log("Base servers:", Object.keys(baseConfig.mcpServers));
        console.log("Custom servers:", Object.keys(customConfig.mcpServers));
        console.log("Config structure:", {
            mcpServers: Object.keys(mergedConfig.mcpServers),
            customServers: Object.keys(mergedConfig.customServers || {}),
            defaults: mergedConfig.defaults ? "present" : "missing",
        });
        console.log("\nFull merged config:", JSON.stringify(mergedConfig, null, 2));
        return mergedConfig;
    }
    catch (error) {
        console.error("Error loading MCP config:", error);
        return { mcpServers: {} };
    }
}
export default function mcpProxy({ transportToClient, transportToServer, onerror, }) {
    let transportToClientClosed = false;
    let transportToServerClosed = false;
    transportToClient.onmessage = (message) => {
        console.log("transportToClient.onmessage", message);
        transportToServer.send(message).catch(onerror);
    };
    transportToServer.onmessage = (message) => {
        console.log("transportToServer.onmessage", message);
        transportToClient.send(message).catch(onerror);
    };
    transportToClient.onclose = () => {
        console.log("transportToClient.onclose");
        if (transportToServerClosed) {
            return;
        }
        transportToClientClosed = true;
        transportToServer.close().catch(onerror);
    };
    transportToServer.onclose = () => {
        console.log("transportToServer.onclose");
        if (transportToClientClosed) {
            return;
        }
        transportToServerClosed = true;
        transportToClient.close().catch(onerror);
    };
    transportToClient.onerror = onerror;
    transportToServer.onerror = onerror;
}
